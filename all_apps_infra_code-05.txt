### .github/workflows/checks.yml ###
name: Terraform Checks

on:
  pull_request:
    branches: [ "main" ]

jobs:
  checks-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

  checks-pgadmin:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

  checks-marquez:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: marquez
    env:
      TF_VAR_marquez_db_user:     ${{ secrets.MARQUEZ_DB_USER }}
      TF_VAR_marquez_db_password: ${{ secrets.MARQUEZ_DB_PASSWORD }}
      TF_VAR_marquez_db_name:     ${{ vars.MARQUEZ_DB_NAME }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

### .github/workflows/deploy.yml ###
name: Deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

jobs:
  deploy-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform plan -out=tfplan
      - run: terraform apply -auto-approve tfplan

  deploy-pgadmin:
    needs: deploy-shared
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform plan -out=tfplan
      - run: terraform apply -auto-approve tfplan

  deploy-marquez:
    needs: deploy-pgadmin
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: marquez
    env:
      TF_VAR_marquez_db_user:     ${{ secrets.MARQUEZ_DB_USER }}
      TF_VAR_marquez_db_password: ${{ secrets.MARQUEZ_DB_PASSWORD }}
      TF_VAR_marquez_db_name:     ${{ vars.MARQUEZ_DB_NAME }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform plan -out=tfplan
      - run: terraform apply -auto-approve tfplan

### .github/workflows/destroy.yml ###
name: Destroy

on:
  workflow_dispatch: {}

jobs:
  destroy-marquez:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: marquez
    env:
      TF_VAR_marquez_db_user:     ${{ secrets.MARQUEZ_DB_USER }}
      TF_VAR_marquez_db_password: ${{ secrets.MARQUEZ_DB_PASSWORD }}
      TF_VAR_marquez_db_name:     ${{ vars.MARQUEZ_DB_NAME }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform destroy -auto-approve

  destroy-pgadmin:
    needs: destroy-marquez
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform destroy -auto-approve

  destroy-shared:
    needs: destroy-pgadmin
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform destroy -auto-approve

### .github/workflows/test-and-lint.yml ###
name: Test & Lint

on:
  pull_request:

jobs:
  lint-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

  lint-pgadmin:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

  lint-marquez:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: marquez
    env:
      TF_VAR_marquez_db_user:     ${{ secrets.MARQUEZ_DB_USER }}
      TF_VAR_marquez_db_password: ${{ secrets.MARQUEZ_DB_PASSWORD }}
      TF_VAR_marquez_db_name:     ${{ vars.MARQUEZ_DB_NAME }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

### terraform/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "terraform/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks"
    encrypt        = true
  }
}

### terraform/locals.tf ###
locals {
  tags = {
    ManagedBy = "Terraform"
    Layer     = "SharedInfra"
  }
}

### terraform/main.tf ###
############################
# Shared ECS Cluster
############################
resource "aws_ecs_cluster" "shared" {
  name = "shared-ecs-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }

  tags = merge(local.tags, { Name = "shared-ecs-cluster" })
}

############################
# Shared ALB + SG
############################
resource "aws_security_group" "alb" {
  name        = "shared-alb-sg"
  description = "ALB security group"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # (Optional) Enable 443 later
  # ingress { ... }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = merge(local.tags, { Name = "shared-alb-sg" })
}

resource "aws_lb" "shared" {
  name               = "shared-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.public_subnet_ids

  enable_deletion_protection = false
  idle_timeout               = 60

  tags = merge(local.tags, { Name = "shared-alb" })
}

resource "aws_lb_listener" "http" {
  load_balancer_arn = aws_lb.shared.arn
  port              = 80
  protocol          = "HTTP"

  default_action {
    type = "fixed-response"
    fixed_response {
      content_type = "text/plain"
      message_body = "OK"
      status_code  = "200"
    }
  }
}

############################
# Shared EFS (per-app APs)
############################
module "efs" {
  source = "../APP-modules/efs"

  name       = "shared-efs"
  vpc_id     = var.vpc_id
  subnet_ids = var.private_subnet_ids
  tags       = local.tags

  create_security_group = true

  access_points = [
    {
      name        = "pgadmin"
      path        = "/pgadmin"
      uid         = 5050
      gid         = 5050
      permissions = "750"
    },
    {
      name        = "marquez-postgres"
      path        = "/var/lib/postgresql/data"
      uid         = 999 # Typical PostgreSQL user UID, adjust if needed
      gid         = 999 # Typical PostgreSQL group GID, adjust if needed
      permissions = "775"
    },
    {
      name        = "marquez-api"
      path        = "/opt/marquez"
      uid         = 1000 # Match API container user, adjust if needed
      gid         = 1000 # Match API container group, adjust if needed
      permissions = "775"
    }
  ]
}

############################
# VPC Interface Endpoints
############################
module "vpc_endpoints" {
  source = "../APP-modules/vpc_endpoints"

  name                    = "shared-vpce"
  vpc_id                  = var.vpc_id
  region                  = var.region
  subnet_ids              = var.private_subnet_ids
  private_route_table_ids = var.private_route_table_ids
  tags                    = local.tags
}

### terraform/outputs.tf ###
# ECS
output "ecs_cluster_name" {
  value       = aws_ecs_cluster.shared.name
  description = "Shared ECS cluster name"
}

# ALB
output "alb_arn" {
  value       = aws_lb.shared.arn
  description = "Shared ALB ARN"
}
output "alb_dns_name" {
  value       = aws_lb.shared.dns_name
  description = "Shared ALB DNS name"
}
output "alb_listener_arn_80" {
  value       = aws_lb_listener.http.arn
  description = "HTTP(80) listener ARN"
}
output "alb_sg_id" {
  value       = aws_security_group.alb.id
  description = "ALB security group ID"
}

# EFS
output "efs_id" {
  description = "EFS filesystem ID"
  value       = module.efs.file_system_id
}

output "efs_access_points" {
  description = "Map of access point names to IDs"
  value       = module.efs.access_point_ids_by_name
}

output "efs_sg_id" {
  description = "EFS security group ID"
  value       = module.efs.security_group_id
}

# VPC Endpoints
output "vpc_endpoint_ids" {
  description = "IDs of VPC endpoints"
  value       = module.vpc_endpoints.endpoint_ids
}

# VPC/Subnets/Region
output "vpc_id" {
  value = var.vpc_id
}
output "private_subnet_ids" {
  value = var.private_subnet_ids
}
output "public_subnet_ids" {
  value = var.public_subnet_ids
}
output "region" {
  value = var.region
}

### terraform/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region for shared infrastructure"
}

variable "vpc_id" {
  type        = string
  default     = "vpc-0acff19cbcdd28123"
  description = "Existing VPC ID"
}

variable "public_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0096b55bfec0fc1b7",
    "subnet-0baa7f08adef5addb",
    "subnet-03be7e34785dcc9ed"
  ]
  description = "Public subnets for ALB"
}

variable "private_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0f15865ff763a4cd2",
    "subnet-05fe1790c8745cf07",
    "subnet-05a98b6683351fe11"
  ]
  description = "Private subnets for ECS tasks and EFS"
}

variable "private_route_table_ids" {
  type        = list(string)
  default     = ["rtb-04eae072f5cad1ef9"]
  description = "Private route table IDs for VPC Endpoints"
}

### terraform/versions.tf ###
terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

### terraform/terraform.tfvars ###
region = "us-east-1"

vpc_id             = "vpc-0acff19cbcdd28123"
private_subnet_ids = ["subnet-0f15865ff763a4cd2", "subnet-05fe1790c8745cf07", "subnet-05a98b6683351fe11"]
public_subnet_ids  = ["subnet-0096b55bfec0fc1b7", "subnet-0baa7f08adef5addb", "subnet-03be7e34785dcc9ed"]

### pgadmin/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "pgadmin/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks"
    encrypt        = true
  }
}

### pgadmin/locals.tf ###
locals {
  app_name = "pgadmin"

  tags = {
    Application = local.app_name
    Owner       = "DataPlatform"
    ManagedBy   = "Terraform"
  }
}

### pgadmin/main.tf ###
############################
# Bring shared outputs
############################
data "terraform_remote_state" "infra" {
  backend = "s3"
  config = {
    bucket = "pgadmin-terraform-state-test"
    key    = "terraform/terraform.tfstate"
    region = "us-east-1"
  }
}

############################
# ECR (one repo for pgAdmin)
############################
module "ecr" {
  source = "../APP-modules/ecr"
  name   = local.app_name
  tags   = local.tags
}

############################
# IAM roles
############################
module "iam" {
  source = "../APP-modules/iam"
  name   = local.app_name
  tags   = local.tags
}

############################
# Security Group (for tasks)
############################
module "security_groups" {
  source          = "../APP-modules/security_groups"
  name            = local.app_name
  vpc_id          = data.terraform_remote_state.infra.outputs.vpc_id
  container_ports = [80] # Changed from container_port = 80 to container_ports = [80]
  tags            = local.tags
}

############################
# Secrets for login
############################
module "secrets" {
  source           = "../APP-modules/secrets"
  name             = local.app_name
  pgadmin_email    = var.pgadmin_email
  pgadmin_password = var.pgadmin_password
  tags             = local.tags
}

############################
# Logs (split per app)
############################
resource "aws_cloudwatch_log_group" "app" {
  name              = "/ecs/${local.app_name}"
  retention_in_days = 14
  tags              = local.tags
}

############################
# Target Group + ALB Rule
############################
resource "aws_lb_target_group" "app" {
  name        = "${local.app_name}-tg"
  port        = 80
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = data.terraform_remote_state.infra.outputs.vpc_id

  health_check {
    path                = "/misc/ping"
    protocol            = "HTTP"
    matcher             = "200-499"
    interval            = 30
    timeout             = 10
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }

  tags = merge(local.tags, { Name = "${local.app_name}-tg" })
}

resource "aws_lb_listener_rule" "app" {
  listener_arn = data.terraform_remote_state.infra.outputs.alb_listener_arn_80
  priority     = 10

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.app.arn
  }

  condition {
    path_pattern {
      values = ["/*"]
    }
  }

  tags = local.tags
}

############################
# Task Definition
############################
resource "aws_ecs_task_definition" "app" {
  family                   = "${local.app_name}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = "512"
  memory                   = "1024"
  execution_role_arn       = module.iam.execution_role_arn
  task_role_arn            = module.iam.task_role_arn

  container_definitions = jsonencode([
    {
      name      = "pgadmin"
      image     = "${module.ecr.repository_url}:${var.image_tag}"
      essential = true
      portMappings = [
        { containerPort = 80, hostPort = 80, protocol = "tcp" }
      ]
      mountPoints = [
        { sourceVolume = "efs-volume", containerPath = "/var/lib/pgadmin", readOnly = false }
      ]
      secrets = [
        { name = "PGADMIN_DEFAULT_EMAIL", valueFrom = "${module.secrets.pgadmin_secret_arn}:PGADMIN_DEFAULT_EMAIL::" },
        { name = "PGADMIN_DEFAULT_PASSWORD", valueFrom = "${module.secrets.pgadmin_secret_arn}:PGADMIN_DEFAULT_PASSWORD::" }
      ]
      environment = [
        { name = "PGADMIN_LISTEN_PORT", value = "80" }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.app.name
          awslogs-region        = data.terraform_remote_state.infra.outputs.region
          awslogs-stream-prefix = "pgadmin"
        }
      }
    }
  ])

  volume {
    name = "efs-volume"
    efs_volume_configuration {
      file_system_id     = data.terraform_remote_state.infra.outputs.efs_id
      transit_encryption = "ENABLED"
      authorization_config {
        access_point_id = data.terraform_remote_state.infra.outputs.efs_access_points["pgadmin"]
      }
    }
  }

  tags = local.tags
}

############################
# Service (shared cluster)
############################
resource "aws_ecs_service" "app" {
  name            = "${local.app_name}-service"
  cluster         = data.terraform_remote_state.infra.outputs.ecs_cluster_name
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 1
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = data.terraform_remote_state.infra.outputs.private_subnet_ids
    assign_public_ip = false
    security_groups  = [module.security_groups.ecs_sg_id]
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.app.arn
    container_name   = "pgadmin"
    container_port   = 80
  }

  deployment_controller { type = "ECS" }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  enable_execute_command = true

  tags = local.tags
}

### pgadmin/outputs.tf ###
output "pgadmin_alb_dns" {
  description = "ALB DNS name for pgAdmin"
  value       = data.terraform_remote_state.infra.outputs.alb_dns_name
}

output "pgadmin_service_name" {
  description = "ECS service name for pgAdmin"
  value       = aws_ecs_service.app.name
}

output "pgadmin_url" {
  description = "Open pgAdmin in browser"
  value       = "http://${data.terraform_remote_state.infra.outputs.alb_dns_name}/"
}

### pgadmin/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region for pgAdmin deployment"
}

variable "image_tag" {
  type        = string
  default     = "latest"
  description = "ECR image tag for pgAdmin"
}

variable "pgadmin_email" {
  type        = string
  description = "Default pgAdmin admin email (from GitHub Secrets in CI/CD)"
}

variable "pgadmin_password" {
  type        = string
  description = "Default pgAdmin admin password (from GitHub Secrets in CI/CD)"
  sensitive   = true
}

variable "alert_email" {
  type        = string
  description = "Email address for CloudWatch alerts (optional)"
  default     = null
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "private_subnet_ids" {
  type        = list(string)
  description = "Private subnets for ECS tasks"
}

variable "public_subnet_ids" {
  type        = list(string)
  description = "Public subnets for ALB"
}

### pgadmin/terraform.tfvars ###

image_tag        = "latest" # or specific version
pgadmin_email    = "mm_soso33@yahoo.com"
pgadmin_password = "ChangeMe123!" # or omit for CI/CD, where GitHub injects secrets

region = "us-east-1"

vpc_id             = "vpc-0acff19cbcdd28123"
private_subnet_ids = ["subnet-0f15865ff763a4cd2", "subnet-05fe1790c8745cf07", "subnet-05a98b6683351fe11"]
public_subnet_ids  = ["subnet-0096b55bfec0fc1b7", "subnet-0baa7f08adef5addb", "subnet-03be7e34785dcc9ed"]

alert_email = "mm_soso33@yahoo.com"

### marquez/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "marquez/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks"
    encrypt        = true
  }
}

### marquez/locals.tf ###
locals {
  app_name = "marquez"

  tags = {
    Application = local.app_name
    Owner       = "DataPlatform"
    ManagedBy   = "Terraform"
  }
}

### marquez/main.tf ###
############################
# Bring shared outputs
############################
data "terraform_remote_state" "infra" {
  backend = "s3"
  config = {
    bucket = "pgadmin-terraform-state-test"
    key    = "terraform/terraform.tfstate"
    region = "us-east-1"
  }
}

############################
# ECR (3 repos, removed search)
############################
module "ecr_api" {
  source = "../APP-modules/ecr"
  name   = "${local.app_name}-api"
  tags   = local.tags
}
module "ecr_web" {
  source = "../APP-modules/ecr"
  name   = "${local.app_name}-web"
  tags   = local.tags
}
module "ecr_db" {
  source = "../APP-modules/ecr"
  name   = "${local.app_name}-db"
  tags   = local.tags
}

############################
# IAM roles
############################
module "iam" {
  source = "../APP-modules/iam"
  name   = local.app_name
  tags   = local.tags
}

# Data source to get the role name from ARN with explicit dependency
data "aws_iam_role" "task_role" {
  name       = trimprefix(module.iam.task_role_arn, "arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/")
  depends_on = [module.iam] # Ensure iam module is applied first
}

# Fetch the current AWS account ID
data "aws_caller_identity" "current" {}

# Update task role to allow EFS access
resource "aws_iam_role_policy" "task_efs" {
  name = "${local.app_name}-efs-access"
  role = data.aws_iam_role.task_role.name # Use the dynamically fetched role name
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "elasticfilesystem:ClientMount",
          "elasticfilesystem:ClientWrite",
          "elasticfilesystem:ClientRootAccess"
        ]
        Resource = "*"
      }
    ]
  })
  depends_on = [data.aws_iam_role.task_role] # Ensure role is looked up before policy attachment
}

############################
# Security Group (for tasks)
############################
module "security_groups" {
  source          = "../APP-modules/security_groups"
  name            = local.app_name
  vpc_id          = data.terraform_remote_state.infra.outputs.vpc_id
  container_ports = [3000, 5000, 5001, 5432] # Removed 9200, 9600
  tags            = local.tags
}

############################
# Secrets (DB creds)
############################
resource "random_string" "suffix" {
  length  = 5
  special = false
}

resource "aws_secretsmanager_secret" "db" {
  name        = "${local.app_name}-db-${random_string.suffix.result}"
  description = "Credentials for Marquez Postgres"
  tags        = local.tags
}

resource "aws_secretsmanager_secret_version" "db" {
  secret_id = aws_secretsmanager_secret.db.id
  secret_string = jsonencode({
    POSTGRES_USER     = var.marquez_db_user
    POSTGRES_PASSWORD = var.marquez_db_password
    POSTGRES_DB       = var.marquez_db_name
  })
}

############################
# Logs (split per app)
############################
resource "aws_cloudwatch_log_group" "app" {
  name              = "/ecs/${local.app_name}"
  retention_in_days = 14
  tags              = local.tags
}

############################
# Target Group + ALB Rule
############################
resource "aws_lb_target_group" "web" {
  name        = "${local.app_name}-tg"
  port        = 3000
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = data.terraform_remote_state.infra.outputs.vpc_id

  health_check {
    path                = "/"
    protocol            = "HTTP"
    matcher             = "200-499"
    interval            = 30
    timeout             = 10
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }

  tags = merge(local.tags, { Name = "${local.app_name}-tg" })
}

resource "aws_lb_listener_rule" "web" {
  listener_arn = data.terraform_remote_state.infra.outputs.alb_listener_arn_80
  priority     = 20

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.web.arn
  }

  condition {
    path_pattern {
      values = [var.alb_path_prefix]
    }
  }

  tags = local.tags
}

############################
# Task Definition (3 containers, removed search)
########################################################
resource "aws_ecs_task_definition" "app" {
  family                   = "${local.app_name}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.task_cpu
  memory                   = var.task_memory
  execution_role_arn       = module.iam.execution_role_arn
  task_role_arn            = module.iam.task_role_arn

  container_definitions = jsonencode([
    # ---------- DB (Postgres) ----------
    {
      name      = "db"
      image     = "${module.ecr_db.repository_url}:${var.image_tag_db}"
      essential = true
      environment = [
        { name = "POSTGRES_USER", value = var.marquez_db_user },
        { name = "POSTGRES_PASSWORD", value = var.marquez_db_password },
        { name = "POSTGRES_DB", value = var.marquez_db_name }
      ]
      portMappings = [
        { containerPort = 5432, hostPort = 5432, protocol = "tcp" }
      ]
      healthCheck = {
        command     = ["CMD-SHELL", "pg_isready -U ${var.marquez_db_user} -d ${var.marquez_db_name}"],
        interval    = 30
        timeout     = 5
        retries     = 3
        startPeriod = 300
      }
      mountPoints = [
        { sourceVolume = "efs-postgres-volume", containerPath = "/var/lib/postgresql/data", readOnly = false }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.app.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "db"
        }
      }
    },

    # ---------- API ----------
    {
      name      = "api"
      image     = "${module.ecr_api.repository_url}:${var.image_tag_api}"
      essential = true
      portMappings = [
        { containerPort = 5000, hostPort = 5000, protocol = "tcp" },
        { containerPort = 5001, hostPort = 5001, protocol = "tcp" }
      ]
      environment = [
        { name = "MARQUEZ_PORT", value = "5000" },
        { name = "MARQUEZ_ADMIN_PORT", value = "5001" },
        { name = "SEARCH_ENABLED", value = "false" },
        { name = "POSTGRES_HOST", value = "127.0.0.1" },
        { name = "POSTGRES_PORT", value = "5432" }
      ]
      secrets = [
        { name = "POSTGRES_USER", valueFrom = "${aws_secretsmanager_secret.db.arn}:POSTGRES_USER::" },
        { name = "POSTGRES_PASSWORD", valueFrom = "${aws_secretsmanager_secret.db.arn}:POSTGRES_PASSWORD::" },
        { name = "MARQUEZ_DB", valueFrom = "${aws_secretsmanager_secret.db.arn}:POSTGRES_DB::" }
      ]
      mountPoints = [
        { sourceVolume = "efs-api-volume", containerPath = "/opt/marquez", readOnly = false }
      ]
      entryPoint = ["/opt/marquez/wait-for-it.sh", "/app/marquez.jar"] # Use the mounted script
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.app.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "api"
        }
      }
      dependsOn = [
        { containerName = "db", condition = "HEALTHY" }
      ]
      healthCheck = {
        command     = ["CMD-SHELL", "nc -z 127.0.0.1 5432 || exit 1"], # Check if db is reachable
        interval    = 30,
        timeout     = 5,
        retries     = 3,
        startPeriod = 300
      }
    },

    # ---------- WEB ----------
    {
      name      = "web"
      image     = "${module.ecr_web.repository_url}:${var.image_tag_web}"
      essential = true
      portMappings = [
        { containerPort = 3000, hostPort = 3000, protocol = "tcp" }
      ]
      environment = [
        { name = "API_URL", value = "http://api:5000" }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.app.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "web"
        }
      }
      dependsOn = [
        { containerName = "api", condition = "START" }
      ]
    }
  ])

  volume {
    name = "efs-postgres-volume"
    efs_volume_configuration {
      file_system_id     = data.terraform_remote_state.infra.outputs.efs_id
      transit_encryption = "ENABLED"
      authorization_config {
        access_point_id = data.terraform_remote_state.infra.outputs.efs_access_points["marquez-postgres"]
        iam             = "ENABLED"
      }
    }
  }

  volume {
    name = "efs-api-volume"
    efs_volume_configuration {
      file_system_id     = data.terraform_remote_state.infra.outputs.efs_id
      transit_encryption = "ENABLED"
      authorization_config {
        access_point_id = data.terraform_remote_state.infra.outputs.efs_access_points["marquez-api"]
        iam             = "ENABLED"
      }
    }
  }

  tags = local.tags
}

############################
# Service (shared cluster)
resource "aws_ecs_service" "app" {
  name            = "${local.app_name}-service"
  cluster         = data.terraform_remote_state.infra.outputs.ecs_cluster_name
  task_definition = aws_ecs_task_definition.app.arn
  desired_count   = 1
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = data.terraform_remote_state.infra.outputs.private_subnet_ids
    assign_public_ip = false
    security_groups  = [module.security_groups.ecs_sg_id]
  }

  load_balancer {
    target_group_arn = aws_lb_target_group.web.arn
    container_name   = "web"
    container_port   = 3000
  }

  deployment_controller { type = "ECS" }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  enable_execute_command = true

  tags = local.tags
}

### marquez/outputs.tf ###
output "marquez_alb_dns" {
  description = "ALB DNS name for Marquez"
  value       = data.terraform_remote_state.infra.outputs.alb_dns_name
}

output "marquez_service_name" {
  description = "ECS service name for Marquez"
  value       = aws_ecs_service.app.name
}

output "marquez_url" {
  description = "Open Marquez web UI in browser"
  value       = "http://${data.terraform_remote_state.infra.outputs.alb_dns_name}${var.alb_path_prefix}"
}

### marquez/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region"
}

# Image tags (use Docker Hub images unless you build/push your own to ECR)
variable "image_tag_api" {
  type        = string
  default     = "latest"
  description = "Tag for marquezproject/marquez (API)"
}

variable "image_tag_web" {
  type        = string
  default     = "latest"
  description = "Tag for marquezproject/marquez-web (WEB)"
}

variable "image_tag_db" {
  type        = string
  default     = "latest"
  description = "Tag for postgres"
}

variable "image_tag_search" {
  type        = string
  default     = "latest"
  description = "Tag for opensearchproject/opensearch"
}

variable "marquez_db_user" {
  type        = string
  default     = "marquez"
  description = "Postgres username for Marquez"
}

variable "marquez_db_password" {
  type        = string
  default     = "ChangeMe123!"
  description = "Postgres password for Marquez"
  sensitive   = true
}

variable "marquez_db_name" {
  type        = string
  default     = "marquez"
  description = "Postgres database name"
}

# Path-based routing prefix on the shared ALB
variable "alb_path_prefix" {
  type        = string
  default     = "/marquez/*"
  description = "Listener rule path pattern for Marquez web"
}

# Task size (all 4 containers in one task)
variable "task_cpu" {
  type    = string
  default = "4096"
}
variable "task_memory" {
  type    = string
  default = "8192"
}

### marquez/terraform.tfvars ###
region = "us-east-1"

marquez_db_user     = "marquez"
marquez_db_password = "ChangeMe123!"
marquez_db_name     = "marquez"


### APP-modules/alb/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/alb/main.tf ###
#####################
# Application LB     #
#####################

resource "aws_lb" "this" {
  name               = "${var.name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [var.sg_id]
  subnets            = var.public_subnet_ids

  enable_deletion_protection = false

  tags = merge(var.tags, { Name = "${var.name}-alb" })
}

#####################
# Target Group       #
#####################

resource "aws_lb_target_group" "this" {
  name        = "${var.name}-tg"
  port        = var.container_port
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = var.vpc_id

  health_check {
    path                = "/misc/ping"
    protocol            = "HTTP"
    matcher             = "200-499"
    interval            = 30
    timeout             = 10
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }

  tags = merge(var.tags, { Name = "${var.name}-tg" })
}

#####################
# Listener           #
#####################

resource "aws_lb_listener" "http" {
  load_balancer_arn = aws_lb.this.arn
  port              = 80
  protocol          = "HTTP"

  default_action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.this.arn
  }
}

### APP-modules/alb/outputs.tf ###
output "alb_dns_name" {
  value       = aws_lb.this.dns_name
  description = "DNS name of the ALB"
}

output "target_group_arn" {
  value       = aws_lb_target_group.this.arn
  description = "ARN of the ALB target group"
}

output "listener_arn" {
  value       = aws_lb_listener.http.arn
  description = "ARN of the ALB listener"
}

### APP-modules/alb/variables.tf ###
variable "name" {
  type        = string
  description = "Base name prefix"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "public_subnet_ids" {
  type        = list(string)
  description = "List of public subnet IDs for ALB"
}

variable "sg_id" {
  type        = string
  description = "Security group for ALB"
}

variable "container_port" {
  type        = number
  default     = 80
  description = "Container port that ALB will forward traffic to"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply"
}

### APP-modules/autoscaling/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/autoscaling/main.tf ###
#############################
# ECS Service Autoscaling   #
#############################

resource "aws_appautoscaling_target" "ecs" {
  max_capacity       = var.max_capacity
  min_capacity       = var.min_capacity
  resource_id        = "service/${var.cluster_name}/${var.service_name}"
  scalable_dimension = "ecs:service:DesiredCount"
  service_namespace  = "ecs"
}

resource "aws_appautoscaling_policy" "cpu" {
  name               = "${var.name}-cpu-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageCPUUtilization"
    }
    target_value       = var.cpu_target_value
    scale_in_cooldown  = 60
    scale_out_cooldown = 60
  }
}

resource "aws_appautoscaling_policy" "memory" {
  name               = "${var.name}-memory-scaling"
  policy_type        = "TargetTrackingScaling"
  resource_id        = aws_appautoscaling_target.ecs.resource_id
  scalable_dimension = aws_appautoscaling_target.ecs.scalable_dimension
  service_namespace  = aws_appautoscaling_target.ecs.service_namespace

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = "ECSServiceAverageMemoryUtilization"
    }
    target_value       = var.memory_target_value
    scale_in_cooldown  = 60
    scale_out_cooldown = 60
  }
}

### APP-modules/autoscaling/outputs.tf ###
output "autoscaling_target_id" {
  value       = aws_appautoscaling_target.ecs.resource_id
  description = "Resource ID for ECS autoscaling"
}

### APP-modules/autoscaling/variables.tf ###
variable "name" {
  type        = string
  description = "Application name (used as prefix)"
}

variable "cluster_name" {
  type        = string
  description = "ECS Cluster name"
}

variable "service_name" {
  type        = string
  description = "ECS Service name"
}

variable "min_capacity" {
  type        = number
  default     = 1
}

variable "max_capacity" {
  type        = number
  default     = 3
}

variable "cpu_target_value" {
  type        = number
  default     = 70
  description = "Target CPU utilization % for autoscaling"
}

variable "memory_target_value" {
  type        = number
  default     = 75
  description = "Target Memory utilization % for autoscaling"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply where supported"
}

### APP-modules/cloudwatch/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/cloudwatch/main.tf ###
#################################
# CloudWatch Alarms + SNS Alerts
#################################

resource "aws_sns_topic" "alerts" {
  name = "${var.name}-alerts"
  tags = local.common_tags
}

resource "aws_sns_topic_subscription" "email" {
  topic_arn = aws_sns_topic.alerts.arn
  protocol  = "email"
  endpoint  = var.alert_email
}

# ðŸ‘‡ New: SNS Policy for CloudWatch â†’ SNS publishing
resource "aws_sns_topic_policy" "alerts_policy" {
  arn    = aws_sns_topic.alerts.arn
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "cloudwatch.amazonaws.com"
        }
        Action   = "SNS:Publish"
        Resource = aws_sns_topic.alerts.arn
      }
    ]
  })
}

# Alarm for high CPU
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "${var.name}-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "CPUUtilization"
  namespace           = "AWS/ECS"
  period              = 60
  statistic           = "Average"
  threshold           = var.cpu_alarm_threshold
  alarm_description   = "High CPU on ${var.service_name}"
  alarm_actions       = [aws_sns_topic.alerts.arn]

  dimensions = {
    ClusterName = var.cluster_name
    ServiceName = var.service_name
  }

  tags = local.common_tags
}

# Alarm for high Memory
resource "aws_cloudwatch_metric_alarm" "memory_high" {
  alarm_name          = "${var.name}-memory-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = 2
  metric_name         = "MemoryUtilization"
  namespace           = "AWS/ECS"
  period              = 60
  statistic           = "Average"
  threshold           = var.memory_alarm_threshold
  alarm_description   = "High Memory on ${var.service_name}"
  alarm_actions       = [aws_sns_topic.alerts.arn]

  dimensions = {
    ClusterName = var.cluster_name
    ServiceName = var.service_name
  }

  tags = local.common_tags
}

### APP-modules/cloudwatch/outputs.tf ###
output "sns_topic_arn" {
  description = "SNS topic ARN for alerts"
  value       = aws_sns_topic.alerts.arn
}

output "cpu_alarm_arn" {
  description = "CloudWatch alarm ARN for high CPU"
  value       = aws_cloudwatch_metric_alarm.cpu_high.arn
}

output "memory_alarm_arn" {
  description = "CloudWatch alarm ARN for high Memory"
  value       = aws_cloudwatch_metric_alarm.memory_high.arn
}

### APP-modules/cloudwatch/variables.tf ###
variable "name" {
  type        = string
  description = "Application name (prefix for alarms and topics)"
}

variable "cluster_name" {
  type        = string
  description = "ECS Cluster name"
}

variable "service_name" {
  type        = string
  description = "ECS Service name"
}

variable "alert_email" {
  type        = string
  description = "Email to subscribe to SNS alerts"
}

variable "cpu_alarm_threshold" {
  type        = number
  default     = 80
  description = "CPU threshold % for alarm"
}

variable "memory_alarm_threshold" {
  type        = number
  default     = 85
  description = "Memory threshold % for alarm"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply to SNS/alarms"
}

### APP-modules/codedeploy/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/codedeploy/main.tf ###
#############################
# CodeDeploy ECS Application
#############################

resource "aws_codedeploy_app" "this" {
  name             = "${var.name}-ecs-app"
  compute_platform = "ECS"
  tags             = local.common_tags
}

#############################
# CodeDeploy ECS Deployment Group
#############################

resource "aws_codedeploy_deployment_group" "this" {
  app_name               = aws_codedeploy_app.this.name
  deployment_group_name  = "${var.name}-ecs-dg"
  service_role_arn       = var.codedeploy_role_arn
  deployment_config_name = "CodeDeployDefault.ECSAllAtOnce"

  ecs_service {
    cluster_name = var.ecs_cluster_name
    service_name = var.ecs_service_name
  }

  load_balancer_info {
    target_group_pair_info {
      target_group {
        name = "${var.name}-tg"
      }
      prod_traffic_route {
        listener_arns = [var.alb_listener_arn]
      }
    }
  }

  auto_rollback_configuration {
    enabled = true
    events  = ["DEPLOYMENT_FAILURE"]
  }

  tags = local.common_tags
}

### APP-modules/codedeploy/outputs.tf ###
output "codedeploy_app_name" {
  value       = aws_codedeploy_app.this.name
  description = "CodeDeploy application name"
}

output "codedeploy_deployment_group_name" {
  value       = aws_codedeploy_deployment_group.this.deployment_group_name
  description = "CodeDeploy deployment group name"
}

### APP-modules/codedeploy/variables.tf ###
variable "name" {
  type        = string
  default     = "pgadmin"
  description = "Prefix for CodeDeploy resources"
}

variable "ecs_cluster_name" {
  type        = string
  description = "ECS cluster name"
}

variable "ecs_service_name" {
  type        = string
  description = "ECS service name"
}

variable "codedeploy_role_arn" {
  type        = string
  description = "IAM role ARN for CodeDeploy"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Common tags"
}

variable "alb_listener_arn" {
  type        = string
  description = "ALB Listener ARN for CodeDeploy"
}

### APP-modules/ecr/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/ecr/main.tf ###
resource "aws_ecr_repository" "pgadmin" {
  name                 = var.name
  image_tag_mutability = "MUTABLE"

  image_scanning_configuration {
    scan_on_push = true
  }

  tags = merge(
    var.tags,
    {
      Name = var.name
    }
  )
}

# Optional lifecycle policy - keep only the last 10 images
resource "aws_ecr_lifecycle_policy" "pgadmin" {
  repository = aws_ecr_repository.pgadmin.name

  policy = <<EOF
{
  "rules": [
    {
      "rulePriority": 1,
      "description": "Keep last 10 images",
      "selection": {
        "tagStatus": "any",
        "countType": "imageCountMoreThan",
        "countNumber": 10
      },
      "action": {
        "type": "expire"
      }
    }
  ]
}
EOF
}

### APP-modules/ecr/outputs.tf ###
output "repository_url" {
  description = "URL of the ECR repository"
  value       = aws_ecr_repository.pgadmin.repository_url
}

output "repository_arn" {
  description = "ARN of the ECR repository"
  value       = aws_ecr_repository.pgadmin.arn
}

### APP-modules/ecr/variables.tf ###
variable "name" {
  type        = string
  description = "Name of the ECR repository"
  default     = "pgadmin"
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply to ECR resources"
  default     = {}
}

### APP-modules/ecs/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/ecs/main.tf ###
##############################
# ECS Cluster for pgAdmin    #
##############################

resource "aws_ecs_cluster" "this" {
  name = "${var.name}-cluster"

  setting {
    name  = "containerInsights"
    value = "enabled"
  }

  tags = merge(local.common_tags, { Name = "${var.name}-cluster" })
}

##############################
# CloudWatch Logs            #
##############################
resource "aws_cloudwatch_log_group" "ecs" {
  name              = "/ecs/${var.name}"
  retention_in_days = 14
  tags              = local.common_tags
}

##############################
# Task Definition for pgAdmin #
##############################

resource "aws_ecs_task_definition" "this" {
  family                   = "${var.name}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.cpu
  memory                   = var.memory
  execution_role_arn       = var.execution_role_arn
  task_role_arn            = var.task_role_arn

  container_definitions = jsonencode([
    {
      name      = "pgadmin"
      image     = "${var.ecr_repo_url}:${var.image_tag}"
      essential = true
      portMappings = [
        {
          containerPort = var.container_port
          hostPort      = var.container_port
          protocol      = "tcp"
        }
      ]
      mountPoints = [
        {
          sourceVolume  = "efs-volume"
          containerPath = "/var/lib/pgadmin"
          readOnly      = false
        }
      ]
      secrets = [
        {
          name      = "PGADMIN_DEFAULT_EMAIL"
          valueFrom = "${var.pgadmin_secret_arn}:PGADMIN_DEFAULT_EMAIL::"
        },
        {
          name      = "PGADMIN_DEFAULT_PASSWORD"
          valueFrom = "${var.pgadmin_secret_arn}:PGADMIN_DEFAULT_PASSWORD::"
        }
      ]
      environment = [
        {
          name  = "PGADMIN_LISTEN_PORT"
          value = "80"
        }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "ecs"
        }
      }
    }
  ])

  volume {
    name = "efs-volume"
    efs_volume_configuration {
      file_system_id     = var.efs_id
      transit_encryption = "ENABLED"
      authorization_config {
        access_point_id = var.efs_access_point_id
      }
    }
  }

  tags = local.common_tags
}

##############################
# ECS Service for pgAdmin    #
##############################

resource "aws_ecs_service" "this" {
  name            = "${var.name}-service"
  cluster         = aws_ecs_cluster.this.id
  task_definition = aws_ecs_task_definition.this.arn
  desired_count   = var.desired_count
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = var.private_subnet_ids
    assign_public_ip = false
    security_groups  = [var.ecs_sg_id]
  }

  # Attach ECS tasks to ALB target group
  load_balancer {
    target_group_arn = var.alb_target_group_arn
    container_name   = "pgadmin"
    container_port   = var.container_port
  }

  deployment_controller {
    type = "ECS"
  }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  enable_execute_command = true

  tags = local.common_tags
}

### APP-modules/ecs/outputs.tf ###
output "ecs_cluster_id" {
  value       = aws_ecs_cluster.this.id
  description = "ECS cluster ID"
}

output "ecs_service_name" {
  value       = aws_ecs_service.this.name
  description = "ECS service name"
}

output "ecs_cluster_name" {
  value       = aws_ecs_cluster.this.name
  description = "ECS cluster name (used for CodeDeploy)"
}

### APP-modules/ecs/variables.tf ###
variable "name" {
  type        = string
  default     = "pgadmin"
  description = "Name prefix"
}

variable "cpu" {
  type        = string
  default     = "512"
  description = "Task CPU"
}

variable "memory" {
  type        = string
  default     = "1024"
  description = "Task Memory"
}

variable "container_port" {
  type        = number
  default     = 80
  description = "Port where pgAdmin listens"
}

variable "desired_count" {
  type        = number
  default     = 1
  description = "Number of tasks to run"
}

variable "execution_role_arn" {
  type        = string
  description = "ECS execution role ARN"
}

variable "task_role_arn" {
  type        = string
  description = "ECS task role ARN"
}

variable "ecr_repo_url" {
  type        = string
  description = "ECR repo URL for pgAdmin image"
}

variable "efs_id" {
  type        = string
  description = "EFS File System ID"
}

variable "efs_access_point_id" {
  type        = string
  description = "EFS Access Point ID for pgAdmin"
}

variable "ecs_sg_id" {
  type        = string
  description = "ECS Security Group ID"
}

variable "public_subnet_ids" {
  type        = list(string)
  description = "Public subnets for ECS tasks"
}

variable "pgadmin_secret_arn" {
  type        = string
  description = "Secrets Manager ARN for pgAdmin login"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Common tags"
}

variable "alb_target_group_arn" {
  type        = string
  description = "ALB Target Group ARN"
}

variable "private_subnet_ids" {
  type        = list(string)
  description = "Private subnet IDs for ECS tasks"
}

variable "region" {
  type        = string
  description = "AWS region for ECS resources (used in log group, etc.)"
}

variable "image_tag" {
  type        = string
  description = "Tag of the Docker image to deploy"
}

### APP-modules/efs/locals.tf ###
locals {
  name = var.name
  tags = merge({ Module = "efs" }, var.tags)
}

### APP-modules/efs/main.tf ###
data "aws_vpc" "this" {
  id = var.vpc_id
}

# Optional SG creation (allow NFS from VPC CIDR)
resource "aws_security_group" "efs" {
  count  = var.create_security_group && var.security_group_id == null ? 1 : 0
  name   = "${local.name}-efs-sg"
  vpc_id = var.vpc_id
  tags   = merge(local.tags, { Name = "${local.name}-efs-sg" })

  ingress {
    description = "Allow NFS from VPC"
    from_port   = 2049
    to_port     = 2049
    protocol    = "tcp"
    cidr_blocks = [data.aws_vpc.this.cidr_block]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

locals {
  efs_sg_id = var.security_group_id != null ? var.security_group_id : (
    var.create_security_group ? aws_security_group.efs[0].id : null
  )
}

resource "aws_efs_file_system" "this" {
  creation_token = local.name
  encrypted      = true
  tags           = merge(local.tags, { Name = "${local.name}-efs" })
}

# One mount target per private subnet
resource "aws_efs_mount_target" "this" {
  for_each = { for idx, sid in var.subnet_ids : idx => sid }

  file_system_id  = aws_efs_file_system.this.id
  subnet_id       = each.value
  security_groups = local.efs_sg_id == null ? [] : [local.efs_sg_id]
}

# Create multiple access points, one per app (pgadmin, marquez, ...)
resource "aws_efs_access_point" "ap" {
  for_each      = { for ap in var.access_points : ap.name => ap }
  file_system_id = aws_efs_file_system.this.id

  root_directory {
    path = each.value.path
    creation_info {
      owner_uid   = each.value.uid
      owner_gid   = each.value.gid
      permissions = each.value.permissions
    }
  }

  tags = merge(local.tags, {
    Name = "${local.name}-ap-${each.key}"
    App  = each.key
  })
}

### APP-modules/efs/outputs.tf ###
output "file_system_id" {
  description = "EFS filesystem ID"
  value       = aws_efs_file_system.this.id
}

output "security_group_id" {
  description = "Security group ID used for EFS mount targets (if created)"
  value       = local.efs_sg_id
}

output "access_point_ids_by_name" {
  description = "Map of access point name to ID"
  value       = { for k, v in aws_efs_access_point.ap : k => v.id }
}

### APP-modules/efs/variables.tf ###
variable "name" {
  type        = string
  description = "Name prefix for EFS resources"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID where EFS will be created"
}

variable "subnet_ids" {
  type        = list(string)
  description = "List of private subnet IDs for EFS mount targets"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags to apply to resources"
}

variable "create_security_group" {
  type        = bool
  default     = true
  description = "If true, create an SG that allows NFS from the VPC CIDR"
}

variable "security_group_id" {
  type        = string
  default     = null
  description = "If provided, use this SG for EFS mount targets instead of creating one"
}

variable "access_points" {
  description = "List of access points to create"
  type = list(object({
    name        = string
    path        = string
    uid         = number
    gid         = number
    permissions = string
  }))
  default = []
}

### APP-modules/iam/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/iam/main.tf ###
###########################
# ECS Execution Role      #
###########################
resource "aws_iam_role" "execution_role" {
  name               = "${var.name}-ecs-execution-role"
  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume_role.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "execution_role_policy" {
  role       = aws_iam_role.execution_role.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
}

# Allow execution role to read Secrets Manager
resource "aws_iam_role_policy" "execution_role_secrets" {
  name = "${var.name}-ecs-execution-secrets"
  role = aws_iam_role.execution_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect   = "Allow"
        Action   = [
          "secretsmanager:GetSecretValue",
          "secretsmanager:DescribeSecret"
        ]
        Resource = "*" # TODO: restrict to pgadmin secret ARN if you want
      }
    ]
  })
}

###########################
# ECS Task Role           #
###########################
resource "aws_iam_role" "task_role" {
  name               = "${var.name}-ecs-task-role"
  assume_role_policy = data.aws_iam_policy_document.ecs_task_assume_role.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "task_secrets_policy" {
  role       = aws_iam_role.task_role.name
  policy_arn = "arn:aws:iam::aws:policy/SecretsManagerReadWrite"
}

# Attach ECS Exec permissions (SSM)
resource "aws_iam_role_policy_attachment" "task_ssm_policy" {
  role       = aws_iam_role.task_role.name
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

###########################
# CodeDeploy Service Role #
###########################
resource "aws_iam_role" "codedeploy_service_role" {
  name               = "${var.name}-codedeploy-service-role"
  assume_role_policy = data.aws_iam_policy_document.codedeploy_assume.json
  tags               = var.tags
}

resource "aws_iam_role_policy_attachment" "codedeploy_service_role_policy" {
  role       = aws_iam_role.codedeploy_service_role.name
  policy_arn = "arn:aws:iam::aws:policy/AWSCodeDeployRoleForECS"
}

###########################
# Assume Role Policy Docs #
###########################
data "aws_iam_policy_document" "ecs_task_assume_role" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["ecs-tasks.amazonaws.com"]
    }
  }
}

data "aws_iam_policy_document" "codedeploy_assume" {
  statement {
    actions = ["sts:AssumeRole"]
    principals {
      type        = "Service"
      identifiers = ["codedeploy.amazonaws.com"]
    }
  }
}

### APP-modules/iam/outputs.tf ###
output "execution_role_arn" {
  value       = aws_iam_role.execution_role.arn
  description = "ECS Execution Role ARN"
}

output "task_role_arn" {
  value       = aws_iam_role.task_role.arn
  description = "ECS Task Role ARN"
}

output "codedeploy_service_role_arn" {
  value       = aws_iam_role.codedeploy_service_role.arn
  description = "CodeDeploy Service Role ARN"
}

### APP-modules/iam/variables.tf ###
variable "name" {
  description = "Prefix name for IAM roles"
  type        = string
}

variable "tags" {
  description = "Tags for IAM resources"
  type        = map(string)
  default     = {}
}

### APP-modules/secrets/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/secrets/main.tf ###
#############################
# Secrets for pgAdmin Login #
#############################

# Always create a random suffix
resource "random_string" "suffix" {
  length  = 5
  special = false
}

resource "aws_secretsmanager_secret" "pgadmin" {
  # For prod/uat â†’ fixed name
  # For test â†’ you can pass a flag later, but by default just use suffix
  name        = "${var.name}-credentials-${random_string.suffix.result}"
  description = "Credentials for pgAdmin default login"
  tags        = merge(local.common_tags, { Name = "${var.name}-secrets" })
}

resource "aws_secretsmanager_secret_version" "pgadmin" {
  secret_id     = aws_secretsmanager_secret.pgadmin.id
  secret_string = jsonencode({
    PGADMIN_DEFAULT_EMAIL    = var.pgadmin_email
    PGADMIN_DEFAULT_PASSWORD = var.pgadmin_password
  })
}

### APP-modules/secrets/outputs.tf ###
output "pgadmin_secret_arn" {
  description = "ARN of the pgAdmin secret"
  value       = aws_secretsmanager_secret.pgadmin.arn
}

### APP-modules/secrets/variables.tf ###
variable "name" {
  type        = string
  description = "Prefix for the secret name"
  default     = "pgadmin"
}

variable "pgadmin_email" {
  type        = string
  description = "Default pgAdmin login email"
}

variable "pgadmin_password" {
  type        = string
  description = "Default pgAdmin login password"
  sensitive   = true
}

variable "tags" {
  type        = map(string)
  description = "Tags for the secret"
  default     = {}
}

### APP-modules/security_groups/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = "pgadmin"
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/security_groups/main.tf ###
resource "random_string" "suffix" {
  length  = 5
  special = false
}

#####################################
# Security Group for ECS Tasks      #
#####################################
resource "aws_security_group" "ecs" {
  name        = "${var.name}-ecs-sg-${random_string.suffix.result}"
  description = "Security group for ECS tasks"
  vpc_id      = var.vpc_id

  dynamic "ingress" {
    for_each = var.container_ports
    content {
      from_port   = ingress.value
      to_port     = ingress.value
      protocol    = "tcp"
      cidr_blocks = ["0.0.0.0/0"]
    }
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = var.tags
}

#####################################
# Security Group for EFS            #
#####################################
resource "aws_security_group" "efs" {
  name        = "${var.name}-efs-sg-${random_string.suffix.result}"
  description = "Security group for EFS access"
  vpc_id      = var.vpc_id

  ingress {
    from_port       = 2049
    to_port         = 2049
    protocol        = "tcp"
    security_groups = [aws_security_group.ecs.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = var.tags
}

### APP-modules/security_groups/outputs.tf ###
output "ecs_sg_id" {
  description = "Security group ID for ECS tasks"
  value       = aws_security_group.ecs.id
}

output "efs_sg_id" {
  description = "Security group ID for EFS"
  value       = aws_security_group.efs.id
}

### APP-modules/security_groups/variables.tf ###
variable "name" {
  type        = string
  description = "Base name prefix for security groups"
  default     = "pgadmin"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "container_ports" {  # Changed from container_port to container_ports
  type        = list(number)
  default     = [80]
  description = "List of ports where ECS containers listen"
}

variable "tags" {
  type        = map(string)
  description = "Tags to apply"
  default     = {}
}

### APP-modules/vpc_endpoints/locals.tf ###
locals {
  common_tags = merge(
    {
      Application = var.name
      ManagedBy   = "Terraform"
    },
    var.tags
  )
}

### APP-modules/vpc_endpoints/main.tf ###
############################
# Optional Endpoint SG
############################
resource "aws_security_group" "endpoints" {
  count       = var.sg_id == null ? 1 : 0
  name        = "${var.name}-vpce-sg"
  description = "Allow HTTPS from VPC for VPC Interface Endpoints"
  vpc_id      = var.vpc_id

  ingress {
    protocol    = "tcp"
    from_port   = 443
    to_port     = 443
    cidr_blocks = ["0.0.0.0/0"]# Restrict to VPC CIDR
  }

  egress {
    protocol    = "-1"
    from_port   = 0
    to_port     = 0
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = local.common_tags
}

locals {
  vpce_sg_id = var.sg_id != null ? var.sg_id : aws_security_group.endpoints[0].id
}

############################
# Interface Endpoints
############################

# ECR API
resource "aws_vpc_endpoint" "ecr_api" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ecr.api"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ecr-api" })
}

# ECR DKR (image pulls)
resource "aws_vpc_endpoint" "ecr_dkr" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ecr.dkr"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ecr-dkr" })
}

# CloudWatch Logs
resource "aws_vpc_endpoint" "logs" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.logs"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-logs" })
}

# Secrets Manager
resource "aws_vpc_endpoint" "secretsmanager" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.secretsmanager"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-secrets" })
}

# SSM endpoints for ECS Exec
resource "aws_vpc_endpoint" "ssm" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ssm"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ssm" })
}

resource "aws_vpc_endpoint" "ssmmessages" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ssmmessages"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ssmmessages" })
}

resource "aws_vpc_endpoint" "ec2messages" {
  vpc_id              = var.vpc_id
  service_name        = "com.amazonaws.${var.region}.ec2messages"
  vpc_endpoint_type   = "Interface"
  subnet_ids          = var.subnet_ids
  security_group_ids  = [local.vpce_sg_id]
  private_dns_enabled = true
  tags                = merge(local.common_tags, { Name = "${var.name}-ec2messages" })
}

############################
# S3 Gateway Endpoint
############################
resource "aws_vpc_endpoint" "s3" {
  count             = length(var.private_route_table_ids) > 0 ? 1 : 0
  vpc_id            = var.vpc_id
  service_name      = "com.amazonaws.${var.region}.s3"
  vpc_endpoint_type = "Gateway"
  route_table_ids   = var.private_route_table_ids
  tags              = merge(local.common_tags, { Name = "${var.name}-s3" })
}

### APP-modules/vpc_endpoints/outputs.tf ###
output "security_group_id" {
  description = "Security group ID attached to interface endpoints"
  value       = local.vpce_sg_id
}

output "endpoint_ids" {
  description = "IDs of created endpoints"
  value = {
    ecr_api      = aws_vpc_endpoint.ecr_api.id
    ecr_dkr      = aws_vpc_endpoint.ecr_dkr.id
    logs         = aws_vpc_endpoint.logs.id
    secrets      = aws_vpc_endpoint.secretsmanager.id
    ssm          = aws_vpc_endpoint.ssm.id
    ssmmessages  = aws_vpc_endpoint.ssmmessages.id
    ec2messages  = aws_vpc_endpoint.ec2messages.id
    s3_gateway   = length(aws_vpc_endpoint.s3) > 0 ? aws_vpc_endpoint.s3[0].id : null
  }
}

### APP-modules/vpc_endpoints/variables.tf ###
variable "name" {
  type        = string
  description = "Prefix for resources"
  default     = "pgadmin"
}

variable "vpc_id" {
  type        = string
  description = "VPC ID"
}

variable "region" {
  type        = string
  description = "AWS region"
}

variable "subnet_ids" {
  type        = list(string)
  description = "Private subnets for interface endpoints"
}

variable "sg_id" {
  type        = string
  default     = null
  description = "Optional SG for endpoints; if null, one is created"
}

variable "private_route_table_ids" {
  type        = list(string)
  default     = []
  description = "Private route table IDs for S3 Gateway endpoint"
}

variable "tags" {
  type        = map(string)
  default     = {}
  description = "Tags"
}
