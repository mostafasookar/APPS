### .github/workflows/checks.yml ###
name: Terraform Checks

on:
  pull_request:
    branches: [ "main" ]

jobs:
  checks-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - name: Terraform fmt check
        run: terraform fmt -check -recursive
      - name: Terraform init (no backend, just lint)
        run: terraform init -backend=false
      - name: Terraform validate
        run: terraform validate

  checks-pgadmin:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - name: Terraform fmt check
        run: terraform fmt -check -recursive
      - name: Terraform init (no backend, just lint)
        run: terraform init -backend=false
      - name: Terraform validate
        run: terraform validate

### .github/workflows/deploy.yml ###
name: Deploy

on:
  push:
    branches: [ "main" ]
  workflow_dispatch: {}

jobs:
  deploy-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform plan -out=tfplan
      - run: terraform apply -auto-approve tfplan

  deploy-pgadmin:
    needs: deploy-shared
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform plan -out=tfplan
      - run: terraform apply -auto-approve tfplan

### .github/workflows/destroy.yml ###
name: Destroy

on:
  workflow_dispatch: {}

jobs:
  destroy-pgadmin:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform destroy -auto-approve

  destroy-shared:
    needs: destroy-pgadmin
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - uses: hashicorp/setup-terraform@v3
      - run: terraform init
      - run: terraform destroy -auto-approve

### .github/workflows/test-and-lint.yml ###
name: Test & Lint

on:
  pull_request:

jobs:
  lint-shared:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

  lint-pgadmin:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: pgadmin
    env:
      TF_VAR_pgadmin_email: ${{ secrets.PGADMIN_EMAIL }}
      TF_VAR_pgadmin_password: ${{ secrets.PGADMIN_PASSWORD }}
      TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}
    steps:
      - uses: actions/checkout@v4
      - uses: hashicorp/setup-terraform@v3
      - run: terraform fmt -check -recursive
      - run: terraform init -backend=false
      - run: terraform validate

### terraform/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "terraform/terraform.tfstate" # shared infra state
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks" # keep existing table
    encrypt        = true
  }
}

### terraform/locals.tf ###
locals {
  tags = {
    ManagedBy = "Terraform"
    Layer     = "SharedInfra"
  }
}

### terraform/main.tf ###
# EFS (shared across apps like pgAdmin, Marquez)
module "efs" {
  source = "../APP-modules/efs"

  name       = "shared-efs"
  vpc_id     = var.vpc_id
  subnet_ids = var.private_subnet_ids
  tags       = local.tags

  create_security_group = true

  access_points = [
    {
      name        = "pgadmin"
      path        = "/pgadmin"
      uid         = 5050
      gid         = 5050
      permissions = "750"
    },
    {
      name        = "marquez"
      path        = "/marquez"
      uid         = 1000
      gid         = 1000
      permissions = "750"
    }
  ]
}

# VPC Endpoints
module "vpc_endpoints" {
  source = "../APP-modules/vpc_endpoints"

  name                    = "shared-vpce"
  vpc_id                  = var.vpc_id
  region                  = var.region
  subnet_ids              = var.private_subnet_ids
  private_route_table_ids = var.private_route_table_ids
  tags                    = local.tags
}

### terraform/outputs.tf ###
output "efs_id" {
  description = "EFS filesystem ID"
  value       = module.efs.file_system_id
}

output "efs_access_points" {
  description = "Map of access point names to IDs"
  value       = module.efs.access_point_ids_by_name
}

output "efs_sg_id" {
  description = "EFS security group ID"
  value       = module.efs.security_group_id
}

output "vpc_endpoint_ids" {
  description = "IDs of VPC endpoints"
  value       = module.vpc_endpoints.endpoint_ids
}

output "vpc_id" {
  value = var.vpc_id
}
output "private_subnet_ids" {
  value = var.private_subnet_ids
}
output "public_subnet_ids" {
  value = var.public_subnet_ids
}
output "region" {
  value = var.region
}

### terraform/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region for shared infrastructure"
}

variable "vpc_id" {
  type        = string
  default     = "vpc-0acff19cbcdd28123"
  description = "Existing VPC ID"
}

variable "public_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0096b55bfec0fc1b7",
    "subnet-0baa7f08adef5addb",
    "subnet-03be7e34785dcc9ed"
  ]
  description = "Public subnets for ALB"
}

variable "private_subnet_ids" {
  type = list(string)
  default = [
    "subnet-0f15865ff763a4cd2",
    "subnet-05fe1790c8745cf07",
    "subnet-05a98b6683351fe11"
  ]
  description = "Private subnets for ECS tasks and EFS"
}

variable "private_route_table_ids" {
  type        = list(string)
  default     = ["rtb-04eae072f5cad1ef9"]
  description = "Private route table IDs for VPC Endpoints"
}

### terraform/versions.tf ###
terraform {
  required_version = ">= 1.3.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.region
}

### terraform/terraform.tfvars ###
region = "us-east-1"

vpc_id             = "vpc-0acff19cbcdd28123"
private_subnet_ids = ["subnet-0f15865ff763a4cd2", "subnet-05fe1790c8745cf07", "subnet-05a98b6683351fe11"]
public_subnet_ids  = ["subnet-0096b55bfec0fc1b7", "subnet-0baa7f08adef5addb", "subnet-03be7e34785dcc9ed"]


### pgadmin/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "pgadmin/terraform.tfstate" # pgadmin app state
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks" # same table for locks
    encrypt        = true
  }
}

### pgadmin/locals.tf ###
locals {
  app_name = "pgadmin"

  tags = {
    Application = local.app_name
    Owner       = "DataPlatform"
  }
}

### pgadmin/main.tf ###
# Import shared infra (terraform/ state)
data "terraform_remote_state" "infra" {
  backend = "s3"
  config = {
    bucket = "pgadmin-terraform-state-test"
    key    = "terraform/terraform.tfstate"
    region = "us-east-1"
  }
}

# ECR Repo
module "ecr" {
  source = "../APP-modules/ecr"
  name   = local.app_name
  tags   = local.tags
}

# IAM Roles
module "iam" {
  source = "../APP-modules/iam"
  name   = local.app_name
  tags   = local.tags
}

# Security Groups
module "security_groups" {
  source         = "../APP-modules/security_groups"
  name           = local.app_name
  vpc_id         = var.vpc_id
  container_port = 80
  tags           = local.tags
}

# Secrets
module "secrets" {
  source           = "../APP-modules/secrets"
  name             = local.app_name
  pgadmin_email    = var.pgadmin_email
  pgadmin_password = var.pgadmin_password
  tags             = local.tags
}

# ALB
module "alb" {
  source            = "../APP-modules/alb"
  name              = local.app_name
  vpc_id            = var.vpc_id
  public_subnet_ids = var.public_subnet_ids
  sg_id             = module.security_groups.ecs_sg_id
  container_port    = 80
  tags              = local.tags
}

# ECS
module "ecs" {
  source               = "../APP-modules/ecs"
  name                 = local.app_name
  execution_role_arn   = module.iam.execution_role_arn
  task_role_arn        = module.iam.task_role_arn
  ecr_repo_url         = module.ecr.repository_url
  image_tag            = var.image_tag
  efs_id               = data.terraform_remote_state.infra.outputs.efs_id
  efs_access_point_id  = data.terraform_remote_state.infra.outputs.efs_access_points[local.app_name]
  ecs_sg_id            = module.security_groups.ecs_sg_id
  alb_target_group_arn = module.alb.target_group_arn
  private_subnet_ids   = var.private_subnet_ids
  public_subnet_ids    = var.public_subnet_ids
  pgadmin_secret_arn   = module.secrets.pgadmin_secret_arn
  region               = var.region
  tags                 = local.tags
}

# Autoscaling
module "pgadmin_autoscaling" {
  source              = "../APP-modules/autoscaling"
  name                = local.app_name
  cluster_name        = module.ecs.ecs_cluster_name
  service_name        = module.ecs.ecs_service_name
  min_capacity        = 1
  max_capacity        = 3
  cpu_target_value    = 70
  memory_target_value = 75
  tags                = local.tags
}

# CloudWatch
module "pgadmin_cloudwatch" {
  source                 = "../APP-modules/cloudwatch"
  name                   = local.app_name
  cluster_name           = module.ecs.ecs_cluster_name
  service_name           = module.ecs.ecs_service_name
  alert_email            = var.alert_email
  cpu_alarm_threshold    = 80
  memory_alarm_threshold = 85
  tags                   = local.tags
}

### pgadmin/outputs.tf ###
output "pgadmin_alb_dns" {
  value       = module.alb.alb_dns_name
  description = "DNS name of the pgAdmin ALB"
}

output "pgadmin_service_name" {
  value       = module.ecs.ecs_service_name
  description = "Name of ECS service for pgAdmin"
}

### pgadmin/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region for pgAdmin deployment"
}

variable "image_tag" {
  type        = string
  default     = "latest"
  description = "ECR image tag for pgAdmin"
}

variable "pgadmin_email" {
  type        = string
  description = "Default pgAdmin admin email (from GitHub Secrets in CI/CD)"
}

variable "pgadmin_password" {
  type        = string
  description = "Default pgAdmin admin password (from GitHub Secrets in CI/CD)"
}

variable "vpc_id" {
  type        = string
  default     = "vpc-0acff19cbcdd28123"
  description = "VPC ID"
}

variable "private_subnet_ids" {
  type        = list(string)
  default     = [
    "subnet-0f15865ff763a4cd2",
    "subnet-05fe1790c8745cf07",
    "subnet-05a98b6683351fe11"
  ]
  description = "Private subnets for ECS tasks"
}

variable "public_subnet_ids" {
  type        = list(string)
  default     = [
    "subnet-0096b55bfec0fc1b7",
    "subnet-0baa7f08adef5addb",
    "subnet-03be7e34785dcc9ed"
  ]
  description = "Public subnets for ALB"
}

variable "alert_email" {
  type        = string
  description = "Email address for CloudWatch alerts (from GitHub Secrets in CI/CD)"
}

### pgadmin/terraform.tfvars ###

image_tag        = "latest" # or specific version
pgadmin_email    = "mm_soso33@yahoo.com"
pgadmin_password = "ChangeMe123!" # or omit for CI/CD, where GitHub injects secrets

region = "us-east-1"

vpc_id             = "vpc-0acff19cbcdd28123"
private_subnet_ids = ["subnet-0f15865ff763a4cd2", "subnet-05fe1790c8745cf07", "subnet-05a98b6683351fe11"]
public_subnet_ids  = ["subnet-0096b55bfec0fc1b7", "subnet-0baa7f08adef5addb", "subnet-03be7e34785dcc9ed"]

alert_email = "mm_soso33@yahoo.com"

### marquez/backend.tf ###
terraform {
  backend "s3" {
    bucket         = "pgadmin-terraform-state-test"
    key            = "marquez/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "pgadmin-terraform-locks"
    encrypt        = true
  }
}

### marquez/locals.tf ###
locals {
  app_name = "marquez"

  tags = {
    Application = local.app_name
    Owner       = "DataPlatform"
    ManagedBy   = "Terraform"
  }
}

### marquez/main.tf ###
############################
# Shared state (VPC / EFS) #
############################
data "terraform_remote_state" "infra" {
  backend = "s3"
  config = {
    bucket = "pgadmin-terraform-state-test"
    key    = "terraform/terraform.tfstate"
    region = "us-east-1"
  }
}

############################
# Reuse existing ECS stuff #
############################

# Reuse the *same ECS cluster* created by pgAdmin module ("pgadmin-cluster")
data "aws_ecs_cluster" "shared" {
  cluster_name = "pgadmin-cluster"
}

# Reuse the *same ALB* created by pgAdmin module ("pgadmin-alb")
data "aws_lb" "shared_alb" {
  name = "pgadmin-alb"
}

# Get the HTTP(80) listener on shared ALB
data "aws_lb_listener" "http" {
  load_balancer_arn = data.aws_lb.shared_alb.arn
  port              = 80
}

############################
# IAM (execution / task)   #
############################
module "iam" {
  source = "../APP-modules/iam"
  name   = local.app_name
  tags   = local.tags
}

############################
# Security Groups (ECS)    #
############################
# We expose only WEB (3000) through ALB; the rest are local to the task
module "security_groups" {
  source         = "../APP-modules/security_groups"
  name           = local.app_name
  vpc_id         = data.terraform_remote_state.infra.outputs.vpc_id
  container_port = 3000
  tags           = local.tags
}

############################
# Secrets (DB creds)       #
############################
resource "random_string" "suffix" {
  length  = 5
  special = false
}

resource "aws_secretsmanager_secret" "marquez_db" {
  name        = "${local.app_name}-db-${random_string.suffix.result}"
  description = "Credentials for Marquez Postgres"
  tags        = local.tags
}

resource "aws_secretsmanager_secret_version" "marquez_db" {
  secret_id     = aws_secretsmanager_secret.marquez_db.id
  secret_string = jsonencode({
    POSTGRES_USER     = var.marquez_db_user
    POSTGRES_PASSWORD = var.marquez_db_password
    POSTGRES_DB       = var.marquez_db_name
  })
}

############################
# CloudWatch Logs          #
############################
resource "aws_cloudwatch_log_group" "ecs" {
  name              = "/ecs/${local.app_name}"
  retention_in_days = 14
  tags              = local.tags
}

############################
# Target group + rule      #
############################
# Target Group for Marquez WEB (port 3000)
resource "aws_lb_target_group" "marquez" {
  name        = "${local.app_name}-tg"
  port        = 3000
  protocol    = "HTTP"
  target_type = "ip"
  vpc_id      = data.terraform_remote_state.infra.outputs.vpc_id

  health_check {
    path                = "/"
    protocol            = "HTTP"
    matcher             = "200-499"
    interval            = 30
    timeout             = 10
    healthy_threshold   = 2
    unhealthy_threshold = 2
  }

  tags = merge(local.tags, { Name = "${local.app_name}-tg" })
}

# Path-based rule on existing ALB listener → forwards /marquez/* to Marquez TG
resource "aws_lb_listener_rule" "marquez" {
  listener_arn = data.aws_lb_listener.http.arn
  priority     = 50

  action {
    type             = "forward"
    target_group_arn = aws_lb_target_group.marquez.arn
  }

  condition {
    path_pattern {
      values = [var.alb_path_prefix]
    }
  }

  tags = local.tags
}

############################
# Task Definition (4 ctrs) #
############################
# One shared EFS volume, mounted to subpaths for db/search if needed.
resource "aws_ecs_task_definition" "marquez" {
  family                   = "${local.app_name}-task"
  network_mode             = "awsvpc"
  requires_compatibilities = ["FARGATE"]
  cpu                      = var.task_cpu
  memory                   = var.task_memory
  execution_role_arn       = module.iam.execution_role_arn
  task_role_arn            = module.iam.task_role_arn

  container_definitions = jsonencode([
    # ---------- WEB ----------
    {
      name      = "web"
      image     = "marquezproject/marquez-web:${var.image_tag_web}"
      essential = true
      portMappings = [
        { containerPort = 3000, hostPort = 3000, protocol = "tcp" }
      ]
      environment = [
        # API runs in same task on port 5000
        { name = "API_URL", value = "http://127.0.0.1:5000" }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "web"
        }
      }
    },

    # ---------- API ----------
    {
      name      = "api"
      image     = "marquezproject/marquez:${var.image_tag_api}"
      essential = true
      portMappings = [
        { containerPort = 5000, hostPort = 5000, protocol = "tcp" },
        { containerPort = 5001, hostPort = 5001, protocol = "tcp" }
      ]
      dependsOn = [
        { containerName = "db",     condition = "START" },
        { containerName = "search", condition = "START" }
      ]
      environment = [
        { name = "MARQUEZ_PORT",       value = "5000" },
        { name = "MARQUEZ_ADMIN_PORT", value = "5001" },
        { name = "SEARCH_ENABLED",     value = "true" },
        { name = "POSTGRES_HOST",      value = "127.0.0.1" },
        { name = "POSTGRES_PORT",      value = "5432" },
      ]
      secrets = [
        { name = "POSTGRES_USER",     valueFrom = "${aws_secretsmanager_secret.marquez_db.arn}:POSTGRES_USER::" },
        { name = "POSTGRES_PASSWORD", valueFrom = "${aws_secretsmanager_secret.marquez_db.arn}:POSTGRES_PASSWORD::" },
        { name = "MARQUEZ_DB",        valueFrom = "${aws_secretsmanager_secret.marquez_db.arn}:POSTGRES_DB::" }
      ]
      mountPoints = [
        { sourceVolume = "efs-volume", containerPath = "/opt/marquez", readOnly = false }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "api"
        }
      }
    },

    # ---------- DB (Postgres) ----------
    {
      name      = "db"
      image     = "postgres:${var.image_tag_db}"
      essential = true
      environment = [
        { name = "POSTGRES_USER",     value = var.marquez_db_user },
        { name = "POSTGRES_PASSWORD", value = var.marquez_db_password },
        { name = "POSTGRES_DB",       value = var.marquez_db_name }
      ]
      portMappings = [
        { containerPort = 5432, hostPort = 5432, protocol = "tcp" }
      ]
      mountPoints = [
        { sourceVolume = "efs-volume", containerPath = "/var/lib/postgresql/data", readOnly = false }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "db"
        }
      }
    },

    # ---------- OpenSearch ----------
    {
      name      = "search"
      image     = "opensearchproject/opensearch:${var.image_tag_search}"
      essential = true
      environment = [
        { name = "discovery.type",      value = "single-node" },
        { name = "plugins.security.disabled", value = "true" }
      ]
      ulimits = [
        { name = "nofile", softLimit = 65536, hardLimit = 65536 }
      ]
      portMappings = [
        { containerPort = 9200, hostPort = 9200, protocol = "tcp" },
        { containerPort = 9600, hostPort = 9600, protocol = "tcp" }
      ]
      mountPoints = [
        { sourceVolume = "efs-volume", containerPath = "/usr/share/opensearch/data", readOnly = false }
      ]
      logConfiguration = {
        logDriver = "awslogs"
        options = {
          awslogs-group         = aws_cloudwatch_log_group.ecs.name
          awslogs-region        = var.region
          awslogs-stream-prefix = "search"
        }
      }
      # OpenSearch needs extra memory; ensure task_memory is sized appropriately.
    }
  ])

  volume {
    name = "efs-volume"
    efs_volume_configuration {
      file_system_id     = data.terraform_remote_state.infra.outputs.efs_id
      transit_encryption = "ENABLED"
      authorization_config {
        # Use the "marquez" EFS access point from shared infra
        access_point_id = data.terraform_remote_state.infra.outputs.efs_access_points["marquez"]
      }
    }
  }

  tags = local.tags
}

############################
# Service (attach to ALB)  #
############################
resource "aws_ecs_service" "marquez" {
  name            = "${local.app_name}-service"
  cluster         = data.aws_ecs_cluster.shared.arn
  task_definition = aws_ecs_task_definition.marquez.arn
  desired_count   = 1
  launch_type     = "FARGATE"

  network_configuration {
    subnets          = data.terraform_remote_state.infra.outputs.private_subnet_ids
    assign_public_ip = false
    security_groups  = [module.security_groups.ecs_sg_id]
  }

  # Attach WEB container to ALB target group
  load_balancer {
    target_group_arn = aws_lb_target_group.marquez.arn
    container_name   = "web"
    container_port   = 3000
  }

  deployment_controller {
    type = "ECS"
  }

  deployment_circuit_breaker {
    enable   = true
    rollback = true
  }

  enable_execute_command = true

  tags = local.tags
}

### marquez/outputs.tf ###
output "alb_dns_name" {
  description = "Shared ALB DNS name"
  value       = data.aws_lb.shared_alb.dns_name
}

output "service_name" {
  value       = aws_ecs_service.marquez.name
  description = "ECS service name for Marquez"
}

### marquez/variables.tf ###
variable "region" {
  type        = string
  default     = "us-east-1"
  description = "AWS region"
}

# Image tags (use Docker Hub images unless you build/push your own to ECR)
variable "image_tag_api" {
  type        = string
  default     = "0.50.0"
  description = "Tag for marquezproject/marquez (API)"
}

variable "image_tag_web" {
  type        = string
  default     = "0.50.0"
  description = "Tag for marquezproject/marquez-web (WEB)"
}

variable "image_tag_db" {
  type        = string
  default     = "14"
  description = "Tag for postgres"
}

variable "image_tag_search" {
  type        = string
  default     = "2.5.0"
  description = "Tag for opensearchproject/opensearch"
}

variable "marquez_db_user" {
  type        = string
  default     = "marquez"
  description = "Postgres username for Marquez"
}

variable "marquez_db_password" {
  type        = string
  default     = "ChangeMe123!"
  description = "Postgres password for Marquez"
  sensitive   = true
}

variable "marquez_db_name" {
  type        = string
  default     = "marquez"
  description = "Postgres database name"
}

# Path-based routing prefix on the shared ALB
variable "alb_path_prefix" {
  type        = string
  default     = "/marquez/*"
  description = "Listener rule path pattern for Marquez web"
}

# Task size (all 4 containers in one task)
variable "task_cpu" {
  type        = string
  default     = "2048"
}
variable "task_memory" {
  type        = string
  default     = "4096"
}

### marquez/terraform.tfvars ###
region  = "us-east-1"

marquez_db_user     = "marquez"
marquez_db_password = "marquezpassword"
marquez_db_name     = "marquez"

